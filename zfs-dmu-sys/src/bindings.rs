/* automatically generated by rust-bindgen */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub const boolean_t_B_FALSE: boolean_t = 0;
pub const boolean_t_B_TRUE: boolean_t = 1;
pub type boolean_t = u32;
pub type u_longlong_t = ::std::os::raw::c_ulonglong;
pub type longlong_t = ::std::os::raw::c_longlong;
pub type offset_t = longlong_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cred {
    _unused: [u8; 0],
}
pub type cred_t = cred;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_node {
    pub list_next: *mut list_node,
    pub list_prev: *mut list_node,
}
#[test]
fn bindgen_test_layout_list_node() {
    assert_eq!(
        ::std::mem::size_of::<list_node>(),
        16usize,
        concat!("Size of: ", stringify!(list_node))
    );
    assert_eq!(
        ::std::mem::align_of::<list_node>(),
        8usize,
        concat!("Alignment of ", stringify!(list_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_node>())).list_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_node),
            "::",
            stringify!(list_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_node>())).list_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_node),
            "::",
            stringify!(list_prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list {
    pub list_size: usize,
    pub list_offset: usize,
    pub list_head: list_node,
}
#[test]
fn bindgen_test_layout_list() {
    assert_eq!(
        ::std::mem::size_of::<list>(),
        32usize,
        concat!("Size of: ", stringify!(list))
    );
    assert_eq!(
        ::std::mem::align_of::<list>(),
        8usize,
        concat!("Alignment of ", stringify!(list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list>())).list_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list),
            "::",
            stringify!(list_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list>())).list_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list),
            "::",
            stringify!(list_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list>())).list_head as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(list),
            "::",
            stringify!(list_head)
        )
    );
}
pub type list_t = list;
pub type inode_timespec_t = timespec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvlist {
    pub nvl_version: i32,
    pub nvl_nvflag: u32,
    pub nvl_priv: u64,
    pub nvl_flag: u32,
    pub nvl_pad: i32,
}
#[test]
fn bindgen_test_layout_nvlist() {
    assert_eq!(
        ::std::mem::size_of::<nvlist>(),
        24usize,
        concat!("Size of: ", stringify!(nvlist))
    );
    assert_eq!(
        ::std::mem::align_of::<nvlist>(),
        8usize,
        concat!("Alignment of ", stringify!(nvlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_nvflag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_nvflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_priv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_flag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_pad as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_pad)
        )
    );
}
pub type task_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskq_ent {
    pub tqent_next: *mut taskq_ent,
    pub tqent_prev: *mut taskq_ent,
    pub tqent_func: task_func_t,
    pub tqent_arg: *mut ::std::os::raw::c_void,
    pub tqent_flags: usize,
}
#[test]
fn bindgen_test_layout_taskq_ent() {
    assert_eq!(
        ::std::mem::size_of::<taskq_ent>(),
        40usize,
        concat!("Size of: ", stringify!(taskq_ent))
    );
    assert_eq!(
        ::std::mem::align_of::<taskq_ent>(),
        8usize,
        concat!("Alignment of ", stringify!(taskq_ent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taskq_ent>())).tqent_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(taskq_ent),
            "::",
            stringify!(tqent_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taskq_ent>())).tqent_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(taskq_ent),
            "::",
            stringify!(tqent_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taskq_ent>())).tqent_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(taskq_ent),
            "::",
            stringify!(tqent_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taskq_ent>())).tqent_arg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(taskq_ent),
            "::",
            stringify!(tqent_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taskq_ent>())).tqent_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(taskq_ent),
            "::",
            stringify!(tqent_flags)
        )
    );
}
pub type taskq_ent_t = taskq_ent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    pub v_size: u64,
    pub v_fd: ::std::os::raw::c_int,
    pub v_path: *mut ::std::os::raw::c_char,
    pub v_dump_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vnode() {
    assert_eq!(
        ::std::mem::size_of::<vnode>(),
        32usize,
        concat!("Size of: ", stringify!(vnode))
    );
    assert_eq!(
        ::std::mem::align_of::<vnode>(),
        8usize,
        concat!("Alignment of ", stringify!(vnode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vnode>())).v_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnode),
            "::",
            stringify!(v_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vnode>())).v_fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnode),
            "::",
            stringify!(v_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vnode>())).v_path as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vnode),
            "::",
            stringify!(v_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vnode>())).v_dump_fd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vnode),
            "::",
            stringify!(v_dump_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa {
    _unused: [u8; 0],
}
pub const zio_priority_ZIO_PRIORITY_SYNC_READ: zio_priority = 0;
pub const zio_priority_ZIO_PRIORITY_SYNC_WRITE: zio_priority = 1;
pub const zio_priority_ZIO_PRIORITY_ASYNC_READ: zio_priority = 2;
pub const zio_priority_ZIO_PRIORITY_ASYNC_WRITE: zio_priority = 3;
pub const zio_priority_ZIO_PRIORITY_SCRUB: zio_priority = 4;
pub const zio_priority_ZIO_PRIORITY_REMOVAL: zio_priority = 5;
pub const zio_priority_ZIO_PRIORITY_INITIALIZING: zio_priority = 6;
pub const zio_priority_ZIO_PRIORITY_TRIM: zio_priority = 7;
pub const zio_priority_ZIO_PRIORITY_NUM_QUEUEABLE: zio_priority = 8;
pub const zio_priority_ZIO_PRIORITY_NOW: zio_priority = 9;
pub type zio_priority = u32;
pub const dmu_objset_type_DMU_OST_NONE: dmu_objset_type = 0;
pub const dmu_objset_type_DMU_OST_META: dmu_objset_type = 1;
pub const dmu_objset_type_DMU_OST_ZFS: dmu_objset_type = 2;
pub const dmu_objset_type_DMU_OST_ZVOL: dmu_objset_type = 3;
pub const dmu_objset_type_DMU_OST_OTHER: dmu_objset_type = 4;
pub const dmu_objset_type_DMU_OST_ANY: dmu_objset_type = 5;
pub const dmu_objset_type_DMU_OST_NUMTYPES: dmu_objset_type = 6;
pub type dmu_objset_type = u32;
pub use self::dmu_objset_type as dmu_objset_type_t;
pub const zfs_logbias_op_t_ZFS_LOGBIAS_LATENCY: zfs_logbias_op_t = 0;
pub const zfs_logbias_op_t_ZFS_LOGBIAS_THROUGHPUT: zfs_logbias_op_t = 1;
pub type zfs_logbias_op_t = u32;
pub const zfs_sync_type_t_ZFS_SYNC_STANDARD: zfs_sync_type_t = 0;
pub const zfs_sync_type_t_ZFS_SYNC_ALWAYS: zfs_sync_type_t = 1;
pub const zfs_sync_type_t_ZFS_SYNC_DISABLED: zfs_sync_type_t = 2;
pub type zfs_sync_type_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zilog {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsl_dataset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsl_pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dnode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arc_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zio_prop {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsl_crypto_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct locked_range {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objset {
    _unused: [u8; 0],
}
pub type objset_t = objset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dmu_tx {
    _unused: [u8; 0],
}
pub type dmu_tx_t = dmu_tx;
pub type dnode_t = dnode;
pub const dmu_object_byteswap_DMU_BSWAP_UINT8: dmu_object_byteswap = 0;
pub const dmu_object_byteswap_DMU_BSWAP_UINT16: dmu_object_byteswap = 1;
pub const dmu_object_byteswap_DMU_BSWAP_UINT32: dmu_object_byteswap = 2;
pub const dmu_object_byteswap_DMU_BSWAP_UINT64: dmu_object_byteswap = 3;
pub const dmu_object_byteswap_DMU_BSWAP_ZAP: dmu_object_byteswap = 4;
pub const dmu_object_byteswap_DMU_BSWAP_DNODE: dmu_object_byteswap = 5;
pub const dmu_object_byteswap_DMU_BSWAP_OBJSET: dmu_object_byteswap = 6;
pub const dmu_object_byteswap_DMU_BSWAP_ZNODE: dmu_object_byteswap = 7;
pub const dmu_object_byteswap_DMU_BSWAP_OLDACL: dmu_object_byteswap = 8;
pub const dmu_object_byteswap_DMU_BSWAP_ACL: dmu_object_byteswap = 9;
pub const dmu_object_byteswap_DMU_BSWAP_NUMFUNCS: dmu_object_byteswap = 10;
pub type dmu_object_byteswap = u32;
pub use self::dmu_object_byteswap as dmu_object_byteswap_t;
pub const dmu_object_type_DMU_OT_NONE: dmu_object_type = 0;
pub const dmu_object_type_DMU_OT_OBJECT_DIRECTORY: dmu_object_type = 1;
pub const dmu_object_type_DMU_OT_OBJECT_ARRAY: dmu_object_type = 2;
pub const dmu_object_type_DMU_OT_PACKED_NVLIST: dmu_object_type = 3;
pub const dmu_object_type_DMU_OT_PACKED_NVLIST_SIZE: dmu_object_type = 4;
pub const dmu_object_type_DMU_OT_BPOBJ: dmu_object_type = 5;
pub const dmu_object_type_DMU_OT_BPOBJ_HDR: dmu_object_type = 6;
pub const dmu_object_type_DMU_OT_SPACE_MAP_HEADER: dmu_object_type = 7;
pub const dmu_object_type_DMU_OT_SPACE_MAP: dmu_object_type = 8;
pub const dmu_object_type_DMU_OT_INTENT_LOG: dmu_object_type = 9;
pub const dmu_object_type_DMU_OT_DNODE: dmu_object_type = 10;
pub const dmu_object_type_DMU_OT_OBJSET: dmu_object_type = 11;
pub const dmu_object_type_DMU_OT_DSL_DIR: dmu_object_type = 12;
pub const dmu_object_type_DMU_OT_DSL_DIR_CHILD_MAP: dmu_object_type = 13;
pub const dmu_object_type_DMU_OT_DSL_DS_SNAP_MAP: dmu_object_type = 14;
pub const dmu_object_type_DMU_OT_DSL_PROPS: dmu_object_type = 15;
pub const dmu_object_type_DMU_OT_DSL_DATASET: dmu_object_type = 16;
pub const dmu_object_type_DMU_OT_ZNODE: dmu_object_type = 17;
pub const dmu_object_type_DMU_OT_OLDACL: dmu_object_type = 18;
pub const dmu_object_type_DMU_OT_PLAIN_FILE_CONTENTS: dmu_object_type = 19;
pub const dmu_object_type_DMU_OT_DIRECTORY_CONTENTS: dmu_object_type = 20;
pub const dmu_object_type_DMU_OT_MASTER_NODE: dmu_object_type = 21;
pub const dmu_object_type_DMU_OT_UNLINKED_SET: dmu_object_type = 22;
pub const dmu_object_type_DMU_OT_ZVOL: dmu_object_type = 23;
pub const dmu_object_type_DMU_OT_ZVOL_PROP: dmu_object_type = 24;
pub const dmu_object_type_DMU_OT_PLAIN_OTHER: dmu_object_type = 25;
pub const dmu_object_type_DMU_OT_UINT64_OTHER: dmu_object_type = 26;
pub const dmu_object_type_DMU_OT_ZAP_OTHER: dmu_object_type = 27;
pub const dmu_object_type_DMU_OT_ERROR_LOG: dmu_object_type = 28;
pub const dmu_object_type_DMU_OT_SPA_HISTORY: dmu_object_type = 29;
pub const dmu_object_type_DMU_OT_SPA_HISTORY_OFFSETS: dmu_object_type = 30;
pub const dmu_object_type_DMU_OT_POOL_PROPS: dmu_object_type = 31;
pub const dmu_object_type_DMU_OT_DSL_PERMS: dmu_object_type = 32;
pub const dmu_object_type_DMU_OT_ACL: dmu_object_type = 33;
pub const dmu_object_type_DMU_OT_SYSACL: dmu_object_type = 34;
pub const dmu_object_type_DMU_OT_FUID: dmu_object_type = 35;
pub const dmu_object_type_DMU_OT_FUID_SIZE: dmu_object_type = 36;
pub const dmu_object_type_DMU_OT_NEXT_CLONES: dmu_object_type = 37;
pub const dmu_object_type_DMU_OT_SCAN_QUEUE: dmu_object_type = 38;
pub const dmu_object_type_DMU_OT_USERGROUP_USED: dmu_object_type = 39;
pub const dmu_object_type_DMU_OT_USERGROUP_QUOTA: dmu_object_type = 40;
pub const dmu_object_type_DMU_OT_USERREFS: dmu_object_type = 41;
pub const dmu_object_type_DMU_OT_DDT_ZAP: dmu_object_type = 42;
pub const dmu_object_type_DMU_OT_DDT_STATS: dmu_object_type = 43;
pub const dmu_object_type_DMU_OT_SA: dmu_object_type = 44;
pub const dmu_object_type_DMU_OT_SA_MASTER_NODE: dmu_object_type = 45;
pub const dmu_object_type_DMU_OT_SA_ATTR_REGISTRATION: dmu_object_type = 46;
pub const dmu_object_type_DMU_OT_SA_ATTR_LAYOUTS: dmu_object_type = 47;
pub const dmu_object_type_DMU_OT_SCAN_XLATE: dmu_object_type = 48;
pub const dmu_object_type_DMU_OT_DEDUP: dmu_object_type = 49;
pub const dmu_object_type_DMU_OT_DEADLIST: dmu_object_type = 50;
pub const dmu_object_type_DMU_OT_DEADLIST_HDR: dmu_object_type = 51;
pub const dmu_object_type_DMU_OT_DSL_CLONES: dmu_object_type = 52;
pub const dmu_object_type_DMU_OT_BPOBJ_SUBOBJ: dmu_object_type = 53;
pub const dmu_object_type_DMU_OT_NUMTYPES: dmu_object_type = 54;
pub const dmu_object_type_DMU_OTN_UINT8_DATA: dmu_object_type = 128;
pub const dmu_object_type_DMU_OTN_UINT8_METADATA: dmu_object_type = 192;
pub const dmu_object_type_DMU_OTN_UINT16_DATA: dmu_object_type = 129;
pub const dmu_object_type_DMU_OTN_UINT16_METADATA: dmu_object_type = 193;
pub const dmu_object_type_DMU_OTN_UINT32_DATA: dmu_object_type = 130;
pub const dmu_object_type_DMU_OTN_UINT32_METADATA: dmu_object_type = 194;
pub const dmu_object_type_DMU_OTN_UINT64_DATA: dmu_object_type = 131;
pub const dmu_object_type_DMU_OTN_UINT64_METADATA: dmu_object_type = 195;
pub const dmu_object_type_DMU_OTN_ZAP_DATA: dmu_object_type = 132;
pub const dmu_object_type_DMU_OTN_ZAP_METADATA: dmu_object_type = 196;
pub const dmu_object_type_DMU_OTN_UINT8_ENC_DATA: dmu_object_type = 160;
pub const dmu_object_type_DMU_OTN_UINT8_ENC_METADATA: dmu_object_type = 224;
pub const dmu_object_type_DMU_OTN_UINT16_ENC_DATA: dmu_object_type = 161;
pub const dmu_object_type_DMU_OTN_UINT16_ENC_METADATA: dmu_object_type = 225;
pub const dmu_object_type_DMU_OTN_UINT32_ENC_DATA: dmu_object_type = 162;
pub const dmu_object_type_DMU_OTN_UINT32_ENC_METADATA: dmu_object_type = 226;
pub const dmu_object_type_DMU_OTN_UINT64_ENC_DATA: dmu_object_type = 163;
pub const dmu_object_type_DMU_OTN_UINT64_ENC_METADATA: dmu_object_type = 227;
pub const dmu_object_type_DMU_OTN_ZAP_ENC_DATA: dmu_object_type = 164;
pub const dmu_object_type_DMU_OTN_ZAP_ENC_METADATA: dmu_object_type = 228;
pub type dmu_object_type = u32;
pub use self::dmu_object_type as dmu_object_type_t;
pub type dmu_objset_create_sync_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        os: *mut objset_t,
        arg: *mut ::std::os::raw::c_void,
        cr: *mut cred_t,
        tx: *mut dmu_tx_t,
    ),
>;
extern "C" {
    pub fn dmu_objset_hold(
        name: *const ::std::os::raw::c_char,
        tag: *mut ::std::os::raw::c_void,
        osp: *mut *mut objset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_objset_own(
        name: *const ::std::os::raw::c_char,
        type_: dmu_objset_type_t,
        readonly: boolean_t,
        key_required: boolean_t,
        tag: *mut ::std::os::raw::c_void,
        osp: *mut *mut objset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_objset_rele(os: *mut objset_t, tag: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dmu_objset_disown(
        os: *mut objset_t,
        key_required: boolean_t,
        tag: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dmu_objset_open_ds(
        ds: *mut dsl_dataset,
        osp: *mut *mut objset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_objset_evict_dbufs(os: *mut objset_t);
}
extern "C" {
    pub fn dmu_objset_create(
        name: *const ::std::os::raw::c_char,
        type_: dmu_objset_type_t,
        flags: u64,
        dcp: *mut dsl_crypto_params,
        func: dmu_objset_create_sync_func_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_objset_clone(
        name: *const ::std::os::raw::c_char,
        origin: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_objset_snapshot_one(
        fsname: *const ::std::os::raw::c_char,
        snapname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_objset_snapshot_tmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_objset_find(
        name: *mut ::std::os::raw::c_char,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_objset_byteswap(buf: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    pub fn dmu_objset_remap_indirects(
        fsname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dmu_buf {
    pub db_object: u64,
    pub db_offset: u64,
    pub db_size: u64,
    pub db_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_dmu_buf() {
    assert_eq!(
        ::std::mem::size_of::<dmu_buf>(),
        32usize,
        concat!("Size of: ", stringify!(dmu_buf))
    );
    assert_eq!(
        ::std::mem::align_of::<dmu_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(dmu_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_buf>())).db_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_buf),
            "::",
            stringify!(db_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_buf>())).db_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_buf),
            "::",
            stringify!(db_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_buf>())).db_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_buf),
            "::",
            stringify!(db_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_buf>())).db_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_buf),
            "::",
            stringify!(db_data)
        )
    );
}
pub type dmu_buf_t = dmu_buf;
extern "C" {
    pub fn dmu_object_alloc(
        os: *mut objset_t,
        ot: dmu_object_type_t,
        blocksize: ::std::os::raw::c_int,
        bonus_type: dmu_object_type_t,
        bonus_len: ::std::os::raw::c_int,
        tx: *mut dmu_tx_t,
    ) -> u64;
}
extern "C" {
    pub fn dmu_object_alloc_ibs(
        os: *mut objset_t,
        ot: dmu_object_type_t,
        blocksize: ::std::os::raw::c_int,
        indirect_blockshift: ::std::os::raw::c_int,
        bonustype: dmu_object_type_t,
        bonuslen: ::std::os::raw::c_int,
        tx: *mut dmu_tx_t,
    ) -> u64;
}
extern "C" {
    pub fn dmu_object_alloc_dnsize(
        os: *mut objset_t,
        ot: dmu_object_type_t,
        blocksize: ::std::os::raw::c_int,
        bonus_type: dmu_object_type_t,
        bonus_len: ::std::os::raw::c_int,
        dnodesize: ::std::os::raw::c_int,
        tx: *mut dmu_tx_t,
    ) -> u64;
}
extern "C" {
    pub fn dmu_object_alloc_hold(
        os: *mut objset_t,
        ot: dmu_object_type_t,
        blocksize: ::std::os::raw::c_int,
        indirect_blockshift: ::std::os::raw::c_int,
        bonustype: dmu_object_type_t,
        bonuslen: ::std::os::raw::c_int,
        dnodesize: ::std::os::raw::c_int,
        allocated_dnode: *mut *mut dnode_t,
        tag: *mut ::std::os::raw::c_void,
        tx: *mut dmu_tx_t,
    ) -> u64;
}
extern "C" {
    pub fn dmu_object_claim(
        os: *mut objset_t,
        object: u64,
        ot: dmu_object_type_t,
        blocksize: ::std::os::raw::c_int,
        bonus_type: dmu_object_type_t,
        bonus_len: ::std::os::raw::c_int,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_claim_dnsize(
        os: *mut objset_t,
        object: u64,
        ot: dmu_object_type_t,
        blocksize: ::std::os::raw::c_int,
        bonus_type: dmu_object_type_t,
        bonus_len: ::std::os::raw::c_int,
        dnodesize: ::std::os::raw::c_int,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_reclaim(
        os: *mut objset_t,
        object: u64,
        ot: dmu_object_type_t,
        blocksize: ::std::os::raw::c_int,
        bonustype: dmu_object_type_t,
        bonuslen: ::std::os::raw::c_int,
        txp: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_reclaim_dnsize(
        os: *mut objset_t,
        object: u64,
        ot: dmu_object_type_t,
        blocksize: ::std::os::raw::c_int,
        bonustype: dmu_object_type_t,
        bonuslen: ::std::os::raw::c_int,
        dnodesize: ::std::os::raw::c_int,
        keep_spill: boolean_t,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_rm_spill(
        os: *mut objset_t,
        object: u64,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_free(
        os: *mut objset_t,
        object: u64,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_next(
        os: *mut objset_t,
        objectp: *mut u64,
        hole: boolean_t,
        txg: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_set_nlevels(
        os: *mut objset_t,
        object: u64,
        nlevels: ::std::os::raw::c_int,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_set_blocksize(
        os: *mut objset_t,
        object: u64,
        size: u64,
        ibs: ::std::os::raw::c_int,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_set_maxblkid(
        os: *mut objset_t,
        object: u64,
        maxblkid: u64,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_set_checksum(os: *mut objset_t, object: u64, checksum: u8, tx: *mut dmu_tx_t);
}
extern "C" {
    pub fn dmu_object_set_compress(os: *mut objset_t, object: u64, compress: u8, tx: *mut dmu_tx_t);
}
extern "C" {
    pub fn dmu_object_remap_indirects(
        os: *mut objset_t,
        object: u64,
        txg: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_write_embedded(
        os: *mut objset_t,
        object: u64,
        offset: u64,
        data: *mut ::std::os::raw::c_void,
        etype: u8,
        comp: u8,
        uncompressed_size: ::std::os::raw::c_int,
        compressed_size: ::std::os::raw::c_int,
        byteorder: ::std::os::raw::c_int,
        tx: *mut dmu_tx_t,
    );
}
extern "C" {
    pub fn dmu_write_policy(
        os: *mut objset_t,
        dn: *mut dnode_t,
        level: ::std::os::raw::c_int,
        wp: ::std::os::raw::c_int,
        zp: *mut zio_prop,
    );
}
extern "C" {
    pub fn dmu_bonus_hold(
        os: *mut objset_t,
        object: u64,
        tag: *mut ::std::os::raw::c_void,
        dbp: *mut *mut dmu_buf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_bonus_hold_by_dnode(
        dn: *mut dnode_t,
        tag: *mut ::std::os::raw::c_void,
        dbp: *mut *mut dmu_buf_t,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_bonus_max() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_set_bonus(
        arg1: *mut dmu_buf_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_set_bonustype(
        arg1: *mut dmu_buf_t,
        arg2: dmu_object_type_t,
        arg3: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_get_bonustype(arg1: *mut dmu_buf_t) -> dmu_object_type_t;
}
extern "C" {
    pub fn dmu_rm_spill(
        arg1: *mut objset_t,
        arg2: u64,
        arg3: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_spill_hold_by_bonus(
        bonus: *mut dmu_buf_t,
        flags: u32,
        tag: *mut ::std::os::raw::c_void,
        dbp: *mut *mut dmu_buf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_spill_hold_by_dnode(
        dn: *mut dnode_t,
        flags: u32,
        tag: *mut ::std::os::raw::c_void,
        dbp: *mut *mut dmu_buf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_spill_hold_existing(
        bonus: *mut dmu_buf_t,
        tag: *mut ::std::os::raw::c_void,
        dbp: *mut *mut dmu_buf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_buf_hold(
        os: *mut objset_t,
        object: u64,
        offset: u64,
        tag: *mut ::std::os::raw::c_void,
        arg1: *mut *mut dmu_buf_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_buf_hold_by_dnode(
        dn: *mut dnode_t,
        offset: u64,
        tag: *mut ::std::os::raw::c_void,
        dbp: *mut *mut dmu_buf_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_buf_add_ref(db: *mut dmu_buf_t, tag: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dmu_buf_try_add_ref(
        arg1: *mut dmu_buf_t,
        os: *mut objset_t,
        object: u64,
        blkid: u64,
        tag: *mut ::std::os::raw::c_void,
    ) -> boolean_t;
}
extern "C" {
    pub fn dmu_buf_rele(db: *mut dmu_buf_t, tag: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dmu_buf_refcount(db: *mut dmu_buf_t) -> u64;
}
extern "C" {
    pub fn dmu_buf_user_refcount(db: *mut dmu_buf_t) -> u64;
}
extern "C" {
    pub fn dmu_buf_hold_array_by_bonus(
        db: *mut dmu_buf_t,
        offset: u64,
        length: u64,
        read: boolean_t,
        tag: *mut ::std::os::raw::c_void,
        numbufsp: *mut ::std::os::raw::c_int,
        dbpp: *mut *mut *mut dmu_buf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_buf_rele_array(
        arg1: *mut *mut dmu_buf_t,
        numbufs: ::std::os::raw::c_int,
        tag: *mut ::std::os::raw::c_void,
    );
}
pub type dmu_buf_evict_func_t =
    ::std::option::Option<unsafe extern "C" fn(user_ptr: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dmu_buf_user {
    pub dbu_tqent: taskq_ent_t,
    pub dbu_evict_func_sync: dmu_buf_evict_func_t,
    pub dbu_evict_func_async: dmu_buf_evict_func_t,
}
#[test]
fn bindgen_test_layout_dmu_buf_user() {
    assert_eq!(
        ::std::mem::size_of::<dmu_buf_user>(),
        56usize,
        concat!("Size of: ", stringify!(dmu_buf_user))
    );
    assert_eq!(
        ::std::mem::align_of::<dmu_buf_user>(),
        8usize,
        concat!("Alignment of ", stringify!(dmu_buf_user))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_buf_user>())).dbu_tqent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_buf_user),
            "::",
            stringify!(dbu_tqent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_buf_user>())).dbu_evict_func_sync as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_buf_user),
            "::",
            stringify!(dbu_evict_func_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_buf_user>())).dbu_evict_func_async as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_buf_user),
            "::",
            stringify!(dbu_evict_func_async)
        )
    );
}
pub type dmu_buf_user_t = dmu_buf_user;
extern "C" {
    pub fn dmu_buf_set_user(
        db: *mut dmu_buf_t,
        user: *mut dmu_buf_user_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dmu_buf_set_user_ie(
        db: *mut dmu_buf_t,
        user: *mut dmu_buf_user_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dmu_buf_replace_user(
        db: *mut dmu_buf_t,
        old_user: *mut dmu_buf_user_t,
        new_user: *mut dmu_buf_user_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dmu_buf_remove_user(
        db: *mut dmu_buf_t,
        user: *mut dmu_buf_user_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dmu_buf_get_user(db: *mut dmu_buf_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dmu_buf_get_objset(db: *mut dmu_buf_t) -> *mut objset_t;
}
extern "C" {
    pub fn dmu_buf_dnode_enter(db: *mut dmu_buf_t) -> *mut dnode_t;
}
extern "C" {
    pub fn dmu_buf_dnode_exit(db: *mut dmu_buf_t);
}
extern "C" {
    pub fn dmu_buf_user_evict_wait();
}
extern "C" {
    pub fn dmu_buf_get_blkptr(db: *mut dmu_buf_t) -> *mut blkptr;
}
extern "C" {
    pub fn dmu_buf_will_dirty(db: *mut dmu_buf_t, tx: *mut dmu_tx_t);
}
extern "C" {
    pub fn dmu_buf_is_dirty(db: *mut dmu_buf_t, tx: *mut dmu_tx_t) -> boolean_t;
}
extern "C" {
    pub fn dmu_buf_set_crypt_params(
        db_fake: *mut dmu_buf_t,
        byteorder: boolean_t,
        salt: *const u8,
        iv: *const u8,
        mac: *const u8,
        tx: *mut dmu_tx_t,
    );
}
extern "C" {
    pub fn dmu_tx_create(os: *mut objset_t) -> *mut dmu_tx_t;
}
extern "C" {
    pub fn dmu_tx_hold_write(tx: *mut dmu_tx_t, object: u64, off: u64, len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dmu_tx_hold_write_by_dnode(
        tx: *mut dmu_tx_t,
        dn: *mut dnode_t,
        off: u64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn dmu_tx_hold_free(tx: *mut dmu_tx_t, object: u64, off: u64, len: u64);
}
extern "C" {
    pub fn dmu_tx_hold_free_by_dnode(tx: *mut dmu_tx_t, dn: *mut dnode_t, off: u64, len: u64);
}
extern "C" {
    pub fn dmu_tx_hold_remap_l1indirect(tx: *mut dmu_tx_t, object: u64);
}
extern "C" {
    pub fn dmu_tx_hold_zap(
        tx: *mut dmu_tx_t,
        object: u64,
        add: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn dmu_tx_hold_zap_by_dnode(
        tx: *mut dmu_tx_t,
        dn: *mut dnode_t,
        add: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn dmu_tx_hold_bonus(tx: *mut dmu_tx_t, object: u64);
}
extern "C" {
    pub fn dmu_tx_hold_bonus_by_dnode(tx: *mut dmu_tx_t, dn: *mut dnode_t);
}
extern "C" {
    pub fn dmu_tx_hold_spill(tx: *mut dmu_tx_t, object: u64);
}
extern "C" {
    pub fn dmu_tx_hold_sa(tx: *mut dmu_tx_t, hdl: *mut sa_handle, may_grow: boolean_t);
}
extern "C" {
    pub fn dmu_tx_hold_sa_create(tx: *mut dmu_tx_t, total_size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dmu_tx_abort(tx: *mut dmu_tx_t);
}
extern "C" {
    pub fn dmu_tx_assign(tx: *mut dmu_tx_t, txg_how: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_tx_wait(tx: *mut dmu_tx_t);
}
extern "C" {
    pub fn dmu_tx_commit(tx: *mut dmu_tx_t);
}
extern "C" {
    pub fn dmu_tx_mark_netfree(tx: *mut dmu_tx_t);
}
pub type dmu_tx_callback_func_t = ::std::option::Option<
    unsafe extern "C" fn(dcb_data: *mut ::std::os::raw::c_void, error: ::std::os::raw::c_int),
>;
extern "C" {
    pub fn dmu_tx_callback_register(
        tx: *mut dmu_tx_t,
        dcb_func: dmu_tx_callback_func_t,
        dcb_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dmu_tx_do_callbacks(cb_list: *mut list_t, error: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dmu_free_range(
        os: *mut objset_t,
        object: u64,
        offset: u64,
        size: u64,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_free_long_range(
        os: *mut objset_t,
        object: u64,
        offset: u64,
        size: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_free_long_object(os: *mut objset_t, object: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_read(
        os: *mut objset_t,
        object: u64,
        offset: u64,
        size: u64,
        buf: *mut ::std::os::raw::c_void,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_read_by_dnode(
        dn: *mut dnode_t,
        offset: u64,
        size: u64,
        buf: *mut ::std::os::raw::c_void,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_write(
        os: *mut objset_t,
        object: u64,
        offset: u64,
        size: u64,
        buf: *const ::std::os::raw::c_void,
        tx: *mut dmu_tx_t,
    );
}
extern "C" {
    pub fn dmu_write_by_dnode(
        dn: *mut dnode_t,
        offset: u64,
        size: u64,
        buf: *const ::std::os::raw::c_void,
        tx: *mut dmu_tx_t,
    );
}
extern "C" {
    pub fn dmu_prealloc(os: *mut objset_t, object: u64, offset: u64, size: u64, tx: *mut dmu_tx_t);
}
extern "C" {
    pub fn dmu_request_arcbuf(handle: *mut dmu_buf_t, size: ::std::os::raw::c_int) -> *mut arc_buf;
}
extern "C" {
    pub fn dmu_return_arcbuf(buf: *mut arc_buf);
}
extern "C" {
    pub fn dmu_assign_arcbuf_by_dnode(
        dn: *mut dnode_t,
        offset: u64,
        buf: *mut arc_buf,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_assign_arcbuf_by_dbuf(
        handle: *mut dmu_buf_t,
        offset: u64,
        buf: *mut arc_buf,
        tx: *mut dmu_tx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_copy_from_buf(
        os: *mut objset_t,
        object: u64,
        offset: u64,
        handle: *mut dmu_buf_t,
        tx: *mut dmu_tx_t,
    );
}
extern "C" {
    pub fn dmu_prefetch(
        os: *mut objset_t,
        object: u64,
        level: i64,
        offset: u64,
        len: u64,
        pri: zio_priority,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dmu_object_info {
    pub doi_data_block_size: u32,
    pub doi_metadata_block_size: u32,
    pub doi_type: dmu_object_type_t,
    pub doi_bonus_type: dmu_object_type_t,
    pub doi_bonus_size: u64,
    pub doi_indirection: u8,
    pub doi_checksum: u8,
    pub doi_compress: u8,
    pub doi_nblkptr: u8,
    pub doi_pad: [u8; 4usize],
    pub doi_dnodesize: u64,
    pub doi_physical_blocks_512: u64,
    pub doi_max_offset: u64,
    pub doi_fill_count: u64,
}
#[test]
fn bindgen_test_layout_dmu_object_info() {
    assert_eq!(
        ::std::mem::size_of::<dmu_object_info>(),
        64usize,
        concat!("Size of: ", stringify!(dmu_object_info))
    );
    assert_eq!(
        ::std::mem::align_of::<dmu_object_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dmu_object_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_object_info>())).doi_data_block_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_data_block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_object_info>())).doi_metadata_block_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_metadata_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_bonus_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_bonus_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_bonus_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_bonus_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_indirection as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_indirection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_checksum as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_compress as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_compress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_nblkptr as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_nblkptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_pad as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_dnodesize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_dnodesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_object_info>())).doi_physical_blocks_512 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_physical_blocks_512)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_max_offset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_max_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_info>())).doi_fill_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_info),
            "::",
            stringify!(doi_fill_count)
        )
    );
}
pub type dmu_object_info_t = dmu_object_info;
pub type arc_byteswap_func_t =
    ::std::option::Option<unsafe extern "C" fn(buf: *mut ::std::os::raw::c_void, size: usize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dmu_object_type_info {
    pub ot_byteswap: dmu_object_byteswap_t,
    pub ot_metadata: boolean_t,
    pub ot_dbuf_metadata_cache: boolean_t,
    pub ot_encrypt: boolean_t,
    pub ot_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_dmu_object_type_info() {
    assert_eq!(
        ::std::mem::size_of::<dmu_object_type_info>(),
        24usize,
        concat!("Size of: ", stringify!(dmu_object_type_info))
    );
    assert_eq!(
        ::std::mem::align_of::<dmu_object_type_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dmu_object_type_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_object_type_info>())).ot_byteswap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_type_info),
            "::",
            stringify!(ot_byteswap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_object_type_info>())).ot_metadata as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_type_info),
            "::",
            stringify!(ot_metadata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_object_type_info>())).ot_dbuf_metadata_cache as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_type_info),
            "::",
            stringify!(ot_dbuf_metadata_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_type_info>())).ot_encrypt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_type_info),
            "::",
            stringify!(ot_encrypt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_object_type_info>())).ot_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_type_info),
            "::",
            stringify!(ot_name)
        )
    );
}
pub type dmu_object_type_info_t = dmu_object_type_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dmu_object_byteswap_info {
    pub ob_func: arc_byteswap_func_t,
    pub ob_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_dmu_object_byteswap_info() {
    assert_eq!(
        ::std::mem::size_of::<dmu_object_byteswap_info>(),
        16usize,
        concat!("Size of: ", stringify!(dmu_object_byteswap_info))
    );
    assert_eq!(
        ::std::mem::align_of::<dmu_object_byteswap_info>(),
        8usize,
        concat!("Alignment of ", stringify!(dmu_object_byteswap_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_object_byteswap_info>())).ob_func as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_byteswap_info),
            "::",
            stringify!(ob_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_object_byteswap_info>())).ob_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_object_byteswap_info),
            "::",
            stringify!(ob_name)
        )
    );
}
pub type dmu_object_byteswap_info_t = dmu_object_byteswap_info;
extern "C" {
    pub fn dmu_object_info(
        os: *mut objset_t,
        object: u64,
        doi: *mut dmu_object_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_object_info_from_dnode(dn: *mut dnode_t, doi: *mut dmu_object_info_t);
}
extern "C" {
    pub fn dmu_object_info_from_db(db: *mut dmu_buf_t, doi: *mut dmu_object_info_t);
}
extern "C" {
    pub fn dmu_object_size_from_db(
        db: *mut dmu_buf_t,
        blksize: *mut u32,
        nblk512: *mut u_longlong_t,
    );
}
extern "C" {
    pub fn dmu_object_dnsize_from_db(db: *mut dmu_buf_t, dnsize: *mut ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dmu_objset_stats {
    pub dds_num_clones: u64,
    pub dds_creation_txg: u64,
    pub dds_guid: u64,
    pub dds_type: dmu_objset_type_t,
    pub dds_is_snapshot: u8,
    pub dds_inconsistent: u8,
    pub dds_origin: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dmu_objset_stats() {
    assert_eq!(
        ::std::mem::size_of::<dmu_objset_stats>(),
        288usize,
        concat!("Size of: ", stringify!(dmu_objset_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<dmu_objset_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(dmu_objset_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_objset_stats>())).dds_num_clones as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_objset_stats),
            "::",
            stringify!(dds_num_clones)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_objset_stats>())).dds_creation_txg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_objset_stats),
            "::",
            stringify!(dds_creation_txg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_objset_stats>())).dds_guid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_objset_stats),
            "::",
            stringify!(dds_guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_objset_stats>())).dds_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_objset_stats),
            "::",
            stringify!(dds_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_objset_stats>())).dds_is_snapshot as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_objset_stats),
            "::",
            stringify!(dds_is_snapshot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dmu_objset_stats>())).dds_inconsistent as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_objset_stats),
            "::",
            stringify!(dds_inconsistent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dmu_objset_stats>())).dds_origin as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(dmu_objset_stats),
            "::",
            stringify!(dds_origin)
        )
    );
}
pub type dmu_objset_stats_t = dmu_objset_stats;
extern "C" {
    pub fn dmu_objset_fast_stat(os: *mut objset_t, stat: *mut dmu_objset_stats_t);
}
extern "C" {
    pub fn dmu_objset_stats(os: *mut objset_t, nv: *mut nvlist);
}
extern "C" {
    pub fn dmu_objset_space(
        os: *mut objset_t,
        refdbytesp: *mut u64,
        availbytesp: *mut u64,
        usedobjsp: *mut u64,
        availobjsp: *mut u64,
    );
}
extern "C" {
    pub fn dmu_objset_fsid_guid(os: *mut objset_t) -> u64;
}
extern "C" {
    pub fn dmu_objset_snap_cmtime(os: *mut objset_t) -> inode_timespec_t;
}
extern "C" {
    pub fn dmu_objset_is_snapshot(os: *mut objset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_objset_spa(os: *mut objset_t) -> *mut spa;
}
extern "C" {
    pub fn dmu_objset_zil(os: *mut objset_t) -> *mut zilog;
}
extern "C" {
    pub fn dmu_objset_pool(os: *mut objset_t) -> *mut dsl_pool;
}
extern "C" {
    pub fn dmu_objset_ds(os: *mut objset_t) -> *mut dsl_dataset;
}
extern "C" {
    pub fn dmu_objset_name(os: *mut objset_t, buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn dmu_objset_type(os: *mut objset_t) -> dmu_objset_type_t;
}
extern "C" {
    pub fn dmu_objset_id(os: *mut objset_t) -> u64;
}
extern "C" {
    pub fn dmu_objset_dnodesize(os: *mut objset_t) -> u64;
}
extern "C" {
    pub fn dmu_objset_syncprop(os: *mut objset_t) -> zfs_sync_type_t;
}
extern "C" {
    pub fn dmu_objset_logbias(os: *mut objset_t) -> zfs_logbias_op_t;
}
extern "C" {
    pub fn dmu_snapshot_list_next(
        os: *mut objset_t,
        namelen: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        id: *mut u64,
        offp: *mut u64,
        case_conflict: *mut boolean_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_snapshot_lookup(
        os: *mut objset_t,
        name: *const ::std::os::raw::c_char,
        val: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_snapshot_realname(
        os: *mut objset_t,
        name: *mut ::std::os::raw::c_char,
        real: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
        conflict: *mut boolean_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_dir_list_next(
        os: *mut objset_t,
        namelen: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        idp: *mut u64,
        offp: *mut u64,
    ) -> ::std::os::raw::c_int;
}
pub type objset_used_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        bonustype: dmu_object_type_t,
        bonus: *mut ::std::os::raw::c_void,
        userp: *mut u64,
        groupp: *mut u64,
        projectp: *mut u64,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn dmu_objset_register_type(ost: dmu_objset_type_t, cb: objset_used_cb_t);
}
extern "C" {
    pub fn dmu_objset_set_user(os: *mut objset_t, user_ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dmu_objset_get_user(os: *mut objset_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dmu_tx_get_txg(tx: *mut dmu_tx_t) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zgd {
    pub zgd_lwb: *mut lwb,
    pub zgd_bp: *mut blkptr,
    pub zgd_db: *mut dmu_buf_t,
    pub zgd_lr: *mut locked_range,
    pub zgd_private: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_zgd() {
    assert_eq!(
        ::std::mem::size_of::<zgd>(),
        40usize,
        concat!("Size of: ", stringify!(zgd))
    );
    assert_eq!(
        ::std::mem::align_of::<zgd>(),
        8usize,
        concat!("Alignment of ", stringify!(zgd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zgd>())).zgd_lwb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zgd),
            "::",
            stringify!(zgd_lwb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zgd>())).zgd_bp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zgd),
            "::",
            stringify!(zgd_bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zgd>())).zgd_db as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zgd),
            "::",
            stringify!(zgd_db)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zgd>())).zgd_lr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zgd),
            "::",
            stringify!(zgd_lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zgd>())).zgd_private as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zgd),
            "::",
            stringify!(zgd_private)
        )
    );
}
pub type zgd_t = zgd;
pub type dmu_sync_cb_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut zgd_t, error: ::std::os::raw::c_int)>;
extern "C" {
    pub fn dmu_sync(
        zio: *mut zio,
        txg: u64,
        done: dmu_sync_cb_t,
        zgd: *mut zgd_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_offset_next(
        os: *mut objset_t,
        object: u64,
        hole: boolean_t,
        off: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dmu_init();
}
extern "C" {
    pub fn dmu_fini();
}
pub type dmu_traverse_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        os: *mut objset_t,
        arg: *mut ::std::os::raw::c_void,
        bp: *mut blkptr,
        object: u64,
        offset: u64,
        len: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    pub fn dmu_traverse_objset(
        os: *mut objset_t,
        txg_start: u64,
        cb: dmu_traverse_cb_t,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dmu_diff(
        tosnap_name: *const ::std::os::raw::c_char,
        fromsnap_name: *const ::std::os::raw::c_char,
        vp: *mut vnode,
        offp: *mut offset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lwb {
    pub _address: u8,
}
